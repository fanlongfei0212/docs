# <img src="../../../images/icon/mysql.svg" width="30" height="30" />MySql

---

<img src="../../images/icon/mysql.svg" width="180" height="140" />

## MySql性能影响：

**sql查询速度、服务器硬件、网卡流量、磁盘io都会成为对数据库的影响因素**

## Mysql存储引擎

* 常用的存储引擎：

    1. MYISAM：非事物的存储引擎，不支持事物
    2. CSV存储引擎：以csv格式文件保存数据的非事物型的存储引擎
    3. Archive：只允许查询和新增数据而不允许修改的非事物存储引擎
    4. Memory：内存中的非事物型的存储引擎
    5. NDB：mysql集群所使用的内存型事物存储引擎
    6. InnoDB：最常用的事物型存储引擎，也是5.6之后的默认存储引擎
    
### InnoDB：

**最常用的事物型存储引擎，也是MySql5.6之后的默认存储引擎;在5.5之后的版本支持在线修改表结构的操作，
是不会阻塞对表的写操作，之前是不行的，之前是具有排它锁的**
    
* InnoDB特性：
    1. **完全支持事物的ACID**
    2. **数据是按照主键聚集存储，其他列非主键的数据都指向主键**
    3. **支持行级锁，增强数据的并发能力，支持MVCC，避免读写操作的相互阻塞**
    4. **支持Btree和自适应Hash索引**
    5. **5.6之后支持全文索引，5.7之后支持空间索引**
    
* 不支持在线修改表（ddl操作）结构的场景，不支持指的是会阻塞当前的业务操作：
    1. **第一次在表中添加全文索引以及空间索引的时候**
    2. **删除主键的时候**
    3. **增加自增id的时候**
    4. **修改列类型的时候**
    5. **修改字符集的时候**
    
*  在线ddl存在的问题：
    1. **部分语句不支持在线ddl**
    2. **长时间ddl操作会引起严重的主从延迟**
    3. **无法对ddl进行资源限制，比如cpu、磁盘io**
    
* 如何更安全的执行ddl：

    **使用pt-online-schema-change工具进行执行ddl；使用这个工具，首先会创建一个与原表结构一样的新表，
    新表的结构是相对于原表修改后的结构，然后在分批次的将原表的数据拷贝到新表中，当数据拷贝完成之后，
    再将原表与新表进行重命名，就完成了对表结构的修改。在对表进行重命名的时候会短暂的对原表进行锁定，
    在拷贝数据的过程中不会对表进行锁定，不会影响对数据的读写操作，也不会发生很大的主从延迟。**
    
* InnoDB是如何实现事物的：
    1. **原子性：回滚日志（Undo log）:用于记录数据修改前的状态**
    2. **一致性：重做日志（Redo log）：用于记录数据修改后的状态**
    3. **隔离性：锁：用于资源隔离，分为共享锁和排它锁，共享锁和排它锁是互斥的**
    4. **持久性：Rddo log + Undo log**
    5. **Redo log保证了事物的一致性和持久性，Undo log保证了事物的原子性**
    
* InnoDB读是否会阻塞写：

    **InnoDB的读写分为共享锁和排他锁，共享锁和共享锁是兼容的，而共享锁和排它锁以及排它锁和排它锁之间是不兼容的**

    **查询操作需要对所查询的资源添加共享锁，以保证查询的数据不会被其他的事物进行修改，修改操作需要对资源
    进行添加排它锁，以后保证在修改没有被提交前没有被其他事物进行读取和修改，也就是事物的隔离性的实现方法；**
    
    **共享锁和共享锁是相互兼容的，因为都是读，而排它锁和排它锁以及排它锁和共享锁是不兼容的，也就是会相互阻塞的，
    但是，我们在一个修改的事物没有执行完的时候，对同一数据进行查询是可以查询到的，但是，查询的是修改之前的也就是
    事物提交之前的数据，是没有变化的；这证明读操作是没有被写操作阻塞的，但是共享锁和排它锁是不兼容的，那为什么还
    会查询出来呢，是因为innodn的MVCC机制。**
    
* MVCC：

    **事物一在执行写操作时，对此数据添加了排他锁，事物二对此数据进行读操作时是无法进行读取的，这时，innoDB会去找
    此数据Undo log中的修改之前的数据，将数据进行返回。**